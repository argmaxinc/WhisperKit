// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
extension APIProtocol {
    /// Registers each operation handler with the provided transport.
    /// - Parameters:
    ///   - transport: A transport to which to register the operation handlers.
    ///   - serverURL: A URL used to determine the path prefix for registered
    ///   request handlers.
    ///   - configuration: A set of configuration values for the server.
    ///   - middlewares: A list of middlewares to call before the handler.
    internal func registerHandlers(
        on transport: any ServerTransport,
        serverURL: Foundation.URL = .defaultOpenAPIServerURL,
        configuration: Configuration = .init(),
        middlewares: [any ServerMiddleware] = []
    ) throws {
        let server = UniversalServer(
            serverURL: serverURL,
            handler: self,
            configuration: configuration,
            middlewares: middlewares
        )
        try transport.register(
            {
                try await server.createTranscription(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .post,
            path: server.apiPathComponentsWithServerPrefix("/audio/transcriptions")
        )
        try transport.register(
            {
                try await server.createTranslation(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .post,
            path: server.apiPathComponentsWithServerPrefix("/audio/translations")
        )
    }
}

fileprivate extension UniversalServer where APIHandler: APIProtocol {
    /// Transcribes audio into the input language.
    ///
    /// - Remark: HTTP `POST /audio/transcriptions`.
    /// - Remark: Generated from `#/paths//audio/transcriptions/post(createTranscription)`.
    func createTranscription(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.createTranscription.id,
            using: {
                APIHandler.createTranscription($0)
            },
            deserializer: { request, requestBody, metadata in
                let headers: Operations.createTranscription.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Operations.createTranscription.Input.Body
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "multipart/form-data"
                    ]
                )
                switch chosenContentType {
                case "multipart/form-data":
                    body = try converter.getRequiredRequestBodyAsMultipart(
                        OpenAPIRuntime.MultipartBody<Operations.createTranscription.Input.Body.multipartFormPayload>.self,
                        from: requestBody,
                        transforming: { value in
                            .multipartForm(value)
                        },
                        boundary: contentType.requiredBoundary(),
                        allowsUnknownParts: false,
                        requiredExactlyOncePartNames: [
                            "file",
                            "model"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "language",
                            "prompt",
                            "response_format",
                            "stream",
                            "temperature"
                        ],
                        zeroOrMoreTimesPartNames: [
                            "include[]",
                            "timestamp_granularities[]"
                        ],
                        decoding: { part in
                            let headerFields = part.headerFields
                            let (name, filename) = try converter.extractContentDispositionNameAndFilename(in: headerFields)
                            switch name {
                            case "file":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "*/*"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .file(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "model":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .model(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "language":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .language(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "prompt":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .prompt(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "response_format":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .response_format(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "temperature":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .temperature(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "include[]":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .include_lbrack__rbrack_(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "timestamp_granularities[]":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .timestamp_granularities_lbrack__rbrack_(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "stream":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .stream(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            default:
                                preconditionFailure("Unknown part should be rejected by multipart validation.")
                            }
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.createTranscription.Input(
                    headers: headers,
                    body: body
                )
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    case let .text_event_hyphen_stream(value):
                        try converter.validateAcceptIfPresent(
                            "text/event-stream",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsBinary(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "text/event-stream"
                        )
                    }
                    return (response, body)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// Translates audio into English.
    ///
    /// - Remark: HTTP `POST /audio/translations`.
    /// - Remark: Generated from `#/paths//audio/translations/post(createTranslation)`.
    func createTranslation(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.createTranslation.id,
            using: {
                APIHandler.createTranslation($0)
            },
            deserializer: { request, requestBody, metadata in
                let headers: Operations.createTranslation.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Operations.createTranslation.Input.Body
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "multipart/form-data"
                    ]
                )
                switch chosenContentType {
                case "multipart/form-data":
                    body = try converter.getRequiredRequestBodyAsMultipart(
                        OpenAPIRuntime.MultipartBody<Operations.createTranslation.Input.Body.multipartFormPayload>.self,
                        from: requestBody,
                        transforming: { value in
                            .multipartForm(value)
                        },
                        boundary: contentType.requiredBoundary(),
                        allowsUnknownParts: false,
                        requiredExactlyOncePartNames: [
                            "file",
                            "model"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "language",
                            "prompt",
                            "response_format",
                            "temperature"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        decoding: { part in
                            let headerFields = part.headerFields
                            let (name, filename) = try converter.extractContentDispositionNameAndFilename(in: headerFields)
                            switch name {
                            case "file":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "*/*"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .file(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "model":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .model(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "prompt":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .prompt(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "response_format":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .response_format(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "temperature":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .temperature(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            case "language":
                                try converter.verifyContentTypeIfPresent(
                                    in: headerFields,
                                    matches: "text/plain"
                                )
                                let body = try converter.getRequiredRequestBodyAsBinary(
                                    OpenAPIRuntime.HTTPBody.self,
                                    from: part.body,
                                    transforming: {
                                        $0
                                    }
                                )
                                return .language(.init(
                                    payload: .init(body: body),
                                    filename: filename
                                ))
                            default:
                                preconditionFailure("Unknown part should be rejected by multipart validation.")
                            }
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.createTranslation.Input(
                    headers: headers,
                    body: body
                )
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
}
