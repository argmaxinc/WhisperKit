// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// Transcribes audio into the input language.
    ///
    /// - Remark: HTTP `POST /audio/transcriptions`.
    /// - Remark: Generated from `#/paths//audio/transcriptions/post(createTranscription)`.
    func createTranscription(_ input: Operations.createTranscription.Input) async throws -> Operations.createTranscription.Output
    /// Translates audio into English.
    ///
    /// - Remark: HTTP `POST /audio/translations`.
    /// - Remark: Generated from `#/paths//audio/translations/post(createTranslation)`.
    func createTranslation(_ input: Operations.createTranslation.Input) async throws -> Operations.createTranslation.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// Transcribes audio into the input language.
    ///
    /// - Remark: HTTP `POST /audio/transcriptions`.
    /// - Remark: Generated from `#/paths//audio/transcriptions/post(createTranscription)`.
    public func createTranscription(
        headers: Operations.createTranscription.Input.Headers = .init(),
        body: Operations.createTranscription.Input.Body
    ) async throws -> Operations.createTranscription.Output {
        try await createTranscription(Operations.createTranscription.Input(
            headers: headers,
            body: body
        ))
    }
    /// Translates audio into English.
    ///
    /// - Remark: HTTP `POST /audio/translations`.
    /// - Remark: Generated from `#/paths//audio/translations/post(createTranslation)`.
    public func createTranslation(
        headers: Operations.createTranslation.Input.Headers = .init(),
        body: Operations.createTranslation.Input.Body
    ) async throws -> Operations.createTranslation.Output {
        try await createTranslation(Operations.createTranslation.Input(
            headers: headers,
            body: body
        ))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// - Remark: Generated from `#/components/schemas/CreateTranscriptionRequest`.
        @frozen public enum CreateTranscriptionRequest: Sendable, Hashable {
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionRequest/file`.
            public struct filePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `filePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case file(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranscriptionRequest.filePayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionRequest/model`.
            public struct modelPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `modelPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case model(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranscriptionRequest.modelPayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionRequest/language`.
            public struct languagePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `languagePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case language(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranscriptionRequest.languagePayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionRequest/prompt`.
            public struct promptPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `promptPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case prompt(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranscriptionRequest.promptPayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionRequest/response_format`.
            public struct response_formatPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `response_formatPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case response_format(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranscriptionRequest.response_formatPayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionRequest/temperature`.
            public struct temperaturePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `temperaturePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case temperature(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranscriptionRequest.temperaturePayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionRequest/include[]`.
            public struct include_lbrack__rbrack_Payload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `include_lbrack__rbrack_Payload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case include_lbrack__rbrack_(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranscriptionRequest.include_lbrack__rbrack_Payload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionRequest/timestamp_granularities[]`.
            public struct timestamp_granularities_lbrack__rbrack_Payload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `timestamp_granularities_lbrack__rbrack_Payload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case timestamp_granularities_lbrack__rbrack_(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranscriptionRequest.timestamp_granularities_lbrack__rbrack_Payload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionRequest/stream`.
            public struct streamPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `streamPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case stream(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranscriptionRequest.streamPayload>)
        }
        /// Represents a transcription response returned by model, based on the provided input.
        ///
        /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseJson`.
        public struct CreateTranscriptionResponseJson: Codable, Hashable, Sendable {
            /// The transcribed text.
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseJson/text`.
            public var text: Swift.String
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseJson/logprobsPayload`.
            public struct logprobsPayloadPayload: Codable, Hashable, Sendable {
                /// The token in the transcription.
                ///
                /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseJson/logprobsPayload/token`.
                public var token: Swift.String?
                /// The log probability of the token.
                ///
                /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseJson/logprobsPayload/logprob`.
                public var logprob: Swift.Double?
                /// The bytes of the token.
                ///
                /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseJson/logprobsPayload/bytes`.
                public var bytes: [Swift.Double]?
                /// Creates a new `logprobsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - token: The token in the transcription.
                ///   - logprob: The log probability of the token.
                ///   - bytes: The bytes of the token.
                public init(
                    token: Swift.String? = nil,
                    logprob: Swift.Double? = nil,
                    bytes: [Swift.Double]? = nil
                ) {
                    self.token = token
                    self.logprob = logprob
                    self.bytes = bytes
                }
                public enum CodingKeys: String, CodingKey {
                    case token
                    case logprob
                    case bytes
                }
            }
            /// The log probabilities of the tokens in the transcription. Only returned with the models `gpt-4o-transcribe` and `gpt-4o-mini-transcribe` if `logprobs` is added to the `include` array.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseJson/logprobs`.
            public typealias logprobsPayload = [Components.Schemas.CreateTranscriptionResponseJson.logprobsPayloadPayload]
            /// The log probabilities of the tokens in the transcription. Only returned with the models `gpt-4o-transcribe` and `gpt-4o-mini-transcribe` if `logprobs` is added to the `include` array.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseJson/logprobs`.
            public var logprobs: Components.Schemas.CreateTranscriptionResponseJson.logprobsPayload?
            /// The type of response
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseJson/type`.
            @frozen public enum _typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case CreateTranscriptionResponseJson = "CreateTranscriptionResponseJson"
            }
            /// The type of response
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseJson/type`.
            public var _type: Components.Schemas.CreateTranscriptionResponseJson._typePayload
            /// Creates a new `CreateTranscriptionResponseJson`.
            ///
            /// - Parameters:
            ///   - text: The transcribed text.
            ///   - logprobs: The log probabilities of the tokens in the transcription. Only returned with the models `gpt-4o-transcribe` and `gpt-4o-mini-transcribe` if `logprobs` is added to the `include` array.
            ///   - _type: The type of response
            public init(
                text: Swift.String,
                logprobs: Components.Schemas.CreateTranscriptionResponseJson.logprobsPayload? = nil,
                _type: Components.Schemas.CreateTranscriptionResponseJson._typePayload
            ) {
                self.text = text
                self.logprobs = logprobs
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case logprobs
                case _type = "type"
            }
        }
        /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseStreamEvent`.
        public struct CreateTranscriptionResponseStreamEvent: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseStreamEvent/value1`.
            public var value1: Components.Schemas.TranscriptTextDeltaEvent?
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseStreamEvent/value2`.
            public var value2: Components.Schemas.TranscriptTextDoneEvent?
            /// Creates a new `CreateTranscriptionResponseStreamEvent`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.TranscriptTextDeltaEvent? = nil,
                value2: Components.Schemas.TranscriptTextDoneEvent? = nil
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self.value1 = try .init(from: decoder)
                } catch {
                    errors.append(error)
                }
                do {
                    self.value2 = try .init(from: decoder)
                } catch {
                    errors.append(error)
                }
                try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                    [
                        self.value1,
                        self.value2
                    ],
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1?.encode(to: encoder)
                try self.value2?.encode(to: encoder)
            }
        }
        /// Represents a verbose json transcription response returned by model, based on the provided input.
        ///
        /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseVerboseJson`.
        public struct CreateTranscriptionResponseVerboseJson: Codable, Hashable, Sendable {
            /// The language of the input audio.
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseVerboseJson/language`.
            public var language: Swift.String
            /// The duration of the input audio.
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseVerboseJson/duration`.
            public var duration: Swift.Double
            /// The transcribed text.
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseVerboseJson/text`.
            public var text: Swift.String
            /// Extracted words and their corresponding timestamps.
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseVerboseJson/words`.
            public var words: [Components.Schemas.TranscriptionWord]?
            /// Segments of the transcribed text and their corresponding details.
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseVerboseJson/segments`.
            public var segments: [Components.Schemas.TranscriptionSegment]?
            /// The type of response
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseVerboseJson/type`.
            @frozen public enum _typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case CreateTranscriptionResponseVerboseJson = "CreateTranscriptionResponseVerboseJson"
            }
            /// The type of response
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranscriptionResponseVerboseJson/type`.
            public var _type: Components.Schemas.CreateTranscriptionResponseVerboseJson._typePayload
            /// Creates a new `CreateTranscriptionResponseVerboseJson`.
            ///
            /// - Parameters:
            ///   - language: The language of the input audio.
            ///   - duration: The duration of the input audio.
            ///   - text: The transcribed text.
            ///   - words: Extracted words and their corresponding timestamps.
            ///   - segments: Segments of the transcribed text and their corresponding details.
            ///   - _type: The type of response
            public init(
                language: Swift.String,
                duration: Swift.Double,
                text: Swift.String,
                words: [Components.Schemas.TranscriptionWord]? = nil,
                segments: [Components.Schemas.TranscriptionSegment]? = nil,
                _type: Components.Schemas.CreateTranscriptionResponseVerboseJson._typePayload
            ) {
                self.language = language
                self.duration = duration
                self.text = text
                self.words = words
                self.segments = segments
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case language
                case duration
                case text
                case words
                case segments
                case _type = "type"
            }
        }
        /// - Remark: Generated from `#/components/schemas/CreateTranslationRequest`.
        @frozen public enum CreateTranslationRequest: Sendable, Hashable {
            /// - Remark: Generated from `#/components/schemas/CreateTranslationRequest/file`.
            public struct filePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `filePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case file(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranslationRequest.filePayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranslationRequest/model`.
            public struct modelPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `modelPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case model(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranslationRequest.modelPayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranslationRequest/prompt`.
            public struct promptPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `promptPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case prompt(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranslationRequest.promptPayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranslationRequest/response_format`.
            public struct response_formatPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `response_formatPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case response_format(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranslationRequest.response_formatPayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranslationRequest/temperature`.
            public struct temperaturePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `temperaturePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case temperature(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranslationRequest.temperaturePayload>)
            /// - Remark: Generated from `#/components/schemas/CreateTranslationRequest/language`.
            public struct languagePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `languagePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case language(OpenAPIRuntime.MultipartPart<Components.Schemas.CreateTranslationRequest.languagePayload>)
        }
        /// - Remark: Generated from `#/components/schemas/CreateTranslationResponseJson`.
        public struct CreateTranslationResponseJson: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/CreateTranslationResponseJson/text`.
            public var text: Swift.String
            /// Creates a new `CreateTranslationResponseJson`.
            ///
            /// - Parameters:
            ///   - text:
            public init(text: Swift.String) {
                self.text = text
            }
            public enum CodingKeys: String, CodingKey {
                case text
            }
        }
        /// - Remark: Generated from `#/components/schemas/CreateTranslationResponseVerboseJson`.
        public struct CreateTranslationResponseVerboseJson: Codable, Hashable, Sendable {
            /// The language of the output translation (always `english`).
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranslationResponseVerboseJson/language`.
            public var language: Swift.String
            /// The duration of the input audio.
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranslationResponseVerboseJson/duration`.
            public var duration: Swift.Double
            /// The translated text.
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranslationResponseVerboseJson/text`.
            public var text: Swift.String
            /// Segments of the translated text and their corresponding details.
            ///
            /// - Remark: Generated from `#/components/schemas/CreateTranslationResponseVerboseJson/segments`.
            public var segments: [Components.Schemas.TranscriptionSegment]?
            /// Creates a new `CreateTranslationResponseVerboseJson`.
            ///
            /// - Parameters:
            ///   - language: The language of the output translation (always `english`).
            ///   - duration: The duration of the input audio.
            ///   - text: The translated text.
            ///   - segments: Segments of the translated text and their corresponding details.
            public init(
                language: Swift.String,
                duration: Swift.Double,
                text: Swift.String,
                segments: [Components.Schemas.TranscriptionSegment]? = nil
            ) {
                self.language = language
                self.duration = duration
                self.text = text
                self.segments = segments
            }
            public enum CodingKeys: String, CodingKey {
                case language
                case duration
                case text
                case segments
            }
        }
        /// The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`. For `gpt-4o-transcribe` and `gpt-4o-mini-transcribe`, the only supported format is `json`.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/AudioResponseFormat`.
        @frozen public enum AudioResponseFormat: String, Codable, Hashable, Sendable, CaseIterable {
            case json = "json"
            case text = "text"
            case srt = "srt"
            case verbose_json = "verbose_json"
            case vtt = "vtt"
        }
        /// Emitted when there is an additional text delta. This is also the first event emitted when the transcription starts. Only emitted when you [create a transcription](/docs/api-reference/audio/create-transcription) with the `Stream` parameter set to `true`.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptTextDeltaEvent`.
        public struct TranscriptTextDeltaEvent: Codable, Hashable, Sendable {
            /// The type of the event. Always `transcript.text.delta`.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDeltaEvent/type`.
            @frozen public enum _typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case transcript_period_text_period_delta = "transcript.text.delta"
            }
            /// The type of the event. Always `transcript.text.delta`.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDeltaEvent/type`.
            public var _type: Components.Schemas.TranscriptTextDeltaEvent._typePayload
            /// The text delta that was additionally transcribed.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDeltaEvent/delta`.
            public var delta: Swift.String
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDeltaEvent/logprobsPayload`.
            public struct logprobsPayloadPayload: Codable, Hashable, Sendable {
                /// The token that was used to generate the log probability.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptTextDeltaEvent/logprobsPayload/token`.
                public var token: Swift.String?
                /// The log probability of the token.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptTextDeltaEvent/logprobsPayload/logprob`.
                public var logprob: Swift.Double?
                /// The bytes that were used to generate the log probability.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptTextDeltaEvent/logprobsPayload/bytes`.
                public var bytes: OpenAPIRuntime.OpenAPIArrayContainer?
                /// Creates a new `logprobsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - token: The token that was used to generate the log probability.
                ///   - logprob: The log probability of the token.
                ///   - bytes: The bytes that were used to generate the log probability.
                public init(
                    token: Swift.String? = nil,
                    logprob: Swift.Double? = nil,
                    bytes: OpenAPIRuntime.OpenAPIArrayContainer? = nil
                ) {
                    self.token = token
                    self.logprob = logprob
                    self.bytes = bytes
                }
                public enum CodingKeys: String, CodingKey {
                    case token
                    case logprob
                    case bytes
                }
            }
            /// The log probabilities of the delta. Only included if you [create a transcription](/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDeltaEvent/logprobs`.
            public typealias logprobsPayload = [Components.Schemas.TranscriptTextDeltaEvent.logprobsPayloadPayload]
            /// The log probabilities of the delta. Only included if you [create a transcription](/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDeltaEvent/logprobs`.
            public var logprobs: Components.Schemas.TranscriptTextDeltaEvent.logprobsPayload?
            /// Creates a new `TranscriptTextDeltaEvent`.
            ///
            /// - Parameters:
            ///   - _type: The type of the event. Always `transcript.text.delta`.
            ///   - delta: The text delta that was additionally transcribed.
            ///   - logprobs: The log probabilities of the delta. Only included if you [create a transcription](/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.
            public init(
                _type: Components.Schemas.TranscriptTextDeltaEvent._typePayload,
                delta: Swift.String,
                logprobs: Components.Schemas.TranscriptTextDeltaEvent.logprobsPayload? = nil
            ) {
                self._type = _type
                self.delta = delta
                self.logprobs = logprobs
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case delta
                case logprobs
            }
        }
        /// Emitted when the transcription is complete. Contains the complete transcription text. Only emitted when you [create a transcription](/docs/api-reference/audio/create-transcription) with the `Stream` parameter set to `true`.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptTextDoneEvent`.
        public struct TranscriptTextDoneEvent: Codable, Hashable, Sendable {
            /// The type of the event. Always `transcript.text.done`.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDoneEvent/type`.
            @frozen public enum _typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case transcript_period_text_period_done = "transcript.text.done"
            }
            /// The type of the event. Always `transcript.text.done`.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDoneEvent/type`.
            public var _type: Components.Schemas.TranscriptTextDoneEvent._typePayload
            /// The text that was transcribed.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDoneEvent/text`.
            public var text: Swift.String
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDoneEvent/logprobsPayload`.
            public struct logprobsPayloadPayload: Codable, Hashable, Sendable {
                /// The token that was used to generate the log probability.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptTextDoneEvent/logprobsPayload/token`.
                public var token: Swift.String?
                /// The log probability of the token.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptTextDoneEvent/logprobsPayload/logprob`.
                public var logprob: Swift.Double?
                /// The bytes that were used to generate the log probability.
                ///
                ///
                /// - Remark: Generated from `#/components/schemas/TranscriptTextDoneEvent/logprobsPayload/bytes`.
                public var bytes: OpenAPIRuntime.OpenAPIArrayContainer?
                /// Creates a new `logprobsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - token: The token that was used to generate the log probability.
                ///   - logprob: The log probability of the token.
                ///   - bytes: The bytes that were used to generate the log probability.
                public init(
                    token: Swift.String? = nil,
                    logprob: Swift.Double? = nil,
                    bytes: OpenAPIRuntime.OpenAPIArrayContainer? = nil
                ) {
                    self.token = token
                    self.logprob = logprob
                    self.bytes = bytes
                }
                public enum CodingKeys: String, CodingKey {
                    case token
                    case logprob
                    case bytes
                }
            }
            /// The log probabilities of the individual tokens in the transcription. Only included if you [create a transcription](/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDoneEvent/logprobs`.
            public typealias logprobsPayload = [Components.Schemas.TranscriptTextDoneEvent.logprobsPayloadPayload]
            /// The log probabilities of the individual tokens in the transcription. Only included if you [create a transcription](/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptTextDoneEvent/logprobs`.
            public var logprobs: Components.Schemas.TranscriptTextDoneEvent.logprobsPayload?
            /// Creates a new `TranscriptTextDoneEvent`.
            ///
            /// - Parameters:
            ///   - _type: The type of the event. Always `transcript.text.done`.
            ///   - text: The text that was transcribed.
            ///   - logprobs: The log probabilities of the individual tokens in the transcription. Only included if you [create a transcription](/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.
            public init(
                _type: Components.Schemas.TranscriptTextDoneEvent._typePayload,
                text: Swift.String,
                logprobs: Components.Schemas.TranscriptTextDoneEvent.logprobsPayload? = nil
            ) {
                self._type = _type
                self.text = text
                self.logprobs = logprobs
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case text
                case logprobs
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptionInclude`.
        @frozen public enum TranscriptionInclude: String, Codable, Hashable, Sendable, CaseIterable {
            case logprobs = "logprobs"
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptionSegment`.
        public struct TranscriptionSegment: Codable, Hashable, Sendable {
            /// Unique identifier of the segment.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/id`.
            public var id: Swift.Int
            /// Seek offset of the segment.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/seek`.
            public var seek: Swift.Int
            /// Start time of the segment in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/start`.
            public var start: Swift.Float
            /// End time of the segment in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/end`.
            public var end: Swift.Float
            /// Text content of the segment.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/text`.
            public var text: Swift.String
            /// Array of token IDs for the text content.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/tokens`.
            public var tokens: [Swift.Int]
            /// Temperature parameter used for generating the segment.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/temperature`.
            public var temperature: Swift.Float
            /// Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/avg_logprob`.
            public var avg_logprob: Swift.Float
            /// Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/compression_ratio`.
            public var compression_ratio: Swift.Float
            /// Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/no_speech_prob`.
            public var no_speech_prob: Swift.Float
            /// Creates a new `TranscriptionSegment`.
            ///
            /// - Parameters:
            ///   - id: Unique identifier of the segment.
            ///   - seek: Seek offset of the segment.
            ///   - start: Start time of the segment in seconds.
            ///   - end: End time of the segment in seconds.
            ///   - text: Text content of the segment.
            ///   - tokens: Array of token IDs for the text content.
            ///   - temperature: Temperature parameter used for generating the segment.
            ///   - avg_logprob: Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
            ///   - compression_ratio: Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
            ///   - no_speech_prob: Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
            public init(
                id: Swift.Int,
                seek: Swift.Int,
                start: Swift.Float,
                end: Swift.Float,
                text: Swift.String,
                tokens: [Swift.Int],
                temperature: Swift.Float,
                avg_logprob: Swift.Float,
                compression_ratio: Swift.Float,
                no_speech_prob: Swift.Float
            ) {
                self.id = id
                self.seek = seek
                self.start = start
                self.end = end
                self.text = text
                self.tokens = tokens
                self.temperature = temperature
                self.avg_logprob = avg_logprob
                self.compression_ratio = compression_ratio
                self.no_speech_prob = no_speech_prob
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case seek
                case start
                case end
                case text
                case tokens
                case temperature
                case avg_logprob
                case compression_ratio
                case no_speech_prob
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptionWord`.
        public struct TranscriptionWord: Codable, Hashable, Sendable {
            /// The text content of the word.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionWord/word`.
            public var word: Swift.String
            /// Start time of the word in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionWord/start`.
            public var start: Swift.Float
            /// End time of the word in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionWord/end`.
            public var end: Swift.Float
            /// Creates a new `TranscriptionWord`.
            ///
            /// - Parameters:
            ///   - word: The text content of the word.
            ///   - start: Start time of the word in seconds.
            ///   - end: End time of the word in seconds.
            public init(
                word: Swift.String,
                start: Swift.Float,
                end: Swift.Float
            ) {
                self.word = word
                self.start = start
                self.end = end
            }
            public enum CodingKeys: String, CodingKey {
                case word
                case start
                case end
            }
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {}
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {}
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {}
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// Transcribes audio into the input language.
    ///
    /// - Remark: HTTP `POST /audio/transcriptions`.
    /// - Remark: Generated from `#/paths//audio/transcriptions/post(createTranscription)`.
    public enum createTranscription {
        public static let id: Swift.String = "createTranscription"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/audio/transcriptions/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createTranscription.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createTranscription.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.createTranscription.Input.Headers
            /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/multipartForm`.
                @frozen public enum multipartFormPayload: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/multipartForm/file`.
                    public struct filePayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `filePayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case file(OpenAPIRuntime.MultipartPart<Operations.createTranscription.Input.Body.multipartFormPayload.filePayload>)
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/multipartForm/model`.
                    public struct modelPayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `modelPayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case model(OpenAPIRuntime.MultipartPart<Operations.createTranscription.Input.Body.multipartFormPayload.modelPayload>)
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/multipartForm/language`.
                    public struct languagePayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `languagePayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case language(OpenAPIRuntime.MultipartPart<Operations.createTranscription.Input.Body.multipartFormPayload.languagePayload>)
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/multipartForm/prompt`.
                    public struct promptPayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `promptPayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case prompt(OpenAPIRuntime.MultipartPart<Operations.createTranscription.Input.Body.multipartFormPayload.promptPayload>)
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/multipartForm/response_format`.
                    public struct response_formatPayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `response_formatPayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case response_format(OpenAPIRuntime.MultipartPart<Operations.createTranscription.Input.Body.multipartFormPayload.response_formatPayload>)
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/multipartForm/temperature`.
                    public struct temperaturePayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `temperaturePayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case temperature(OpenAPIRuntime.MultipartPart<Operations.createTranscription.Input.Body.multipartFormPayload.temperaturePayload>)
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/multipartForm/include[]`.
                    public struct include_lbrack__rbrack_Payload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `include_lbrack__rbrack_Payload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case include_lbrack__rbrack_(OpenAPIRuntime.MultipartPart<Operations.createTranscription.Input.Body.multipartFormPayload.include_lbrack__rbrack_Payload>)
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/multipartForm/timestamp_granularities[]`.
                    public struct timestamp_granularities_lbrack__rbrack_Payload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `timestamp_granularities_lbrack__rbrack_Payload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case timestamp_granularities_lbrack__rbrack_(OpenAPIRuntime.MultipartPart<Operations.createTranscription.Input.Body.multipartFormPayload.timestamp_granularities_lbrack__rbrack_Payload>)
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/multipartForm/stream`.
                    public struct streamPayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `streamPayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case stream(OpenAPIRuntime.MultipartPart<Operations.createTranscription.Input.Body.multipartFormPayload.streamPayload>)
                }
                /// - Remark: Generated from `#/paths/audio/transcriptions/POST/requestBody/content/multipart\/form-data`.
                case multipartForm(OpenAPIRuntime.MultipartBody<Operations.createTranscription.Input.Body.multipartFormPayload>)
            }
            public var body: Operations.createTranscription.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.createTranscription.Input.Headers = .init(),
                body: Operations.createTranscription.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/audio/transcriptions/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/responses/200/content/json`.
                    @frozen public enum jsonPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/audio/transcriptions/POST/responses/200/content/json/CreateTranscriptionResponseJson`.
                        case CreateTranscriptionResponseJson(Components.Schemas.CreateTranscriptionResponseJson)
                        /// - Remark: Generated from `#/paths/audio/transcriptions/POST/responses/200/content/json/CreateTranscriptionResponseVerboseJson`.
                        case CreateTranscriptionResponseVerboseJson(Components.Schemas.CreateTranscriptionResponseVerboseJson)
                        public enum CodingKeys: String, CodingKey {
                            case _type = "type"
                        }
                        public init(from decoder: any Decoder) throws {
                            let container = try decoder.container(keyedBy: CodingKeys.self)
                            let discriminator = try container.decode(
                                Swift.String.self,
                                forKey: ._type
                            )
                            switch discriminator {
                            case "CreateTranscriptionResponseJson", "#/components/schemas/CreateTranscriptionResponseJson":
                                self = .CreateTranscriptionResponseJson(try .init(from: decoder))
                            case "CreateTranscriptionResponseVerboseJson", "#/components/schemas/CreateTranscriptionResponseVerboseJson":
                                self = .CreateTranscriptionResponseVerboseJson(try .init(from: decoder))
                            default:
                                throw Swift.DecodingError.unknownOneOfDiscriminator(
                                    discriminatorKey: CodingKeys._type,
                                    discriminatorValue: discriminator,
                                    codingPath: decoder.codingPath
                                )
                            }
                        }
                        public func encode(to encoder: any Encoder) throws {
                            switch self {
                            case let .CreateTranscriptionResponseJson(value):
                                try value.encode(to: encoder)
                            case let .CreateTranscriptionResponseVerboseJson(value):
                                try value.encode(to: encoder)
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/responses/200/content/application\/json`.
                    case json(Operations.createTranscription.Output.Ok.Body.jsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.createTranscription.Output.Ok.Body.jsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/audio/transcriptions/POST/responses/200/content/text\/event-stream`.
                    case text_event_hyphen_stream(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.text_event_hyphen_stream`.
                    ///
                    /// - Throws: An error if `self` is not `.text_event_hyphen_stream`.
                    /// - SeeAlso: `.text_event_hyphen_stream`.
                    public var text_event_hyphen_stream: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .text_event_hyphen_stream(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "text/event-stream",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.createTranscription.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.createTranscription.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//audio/transcriptions/post(createTranscription)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.createTranscription.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.createTranscription.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case text_event_hyphen_stream
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/event-stream":
                    self = .text_event_hyphen_stream
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .text_event_hyphen_stream:
                    return "text/event-stream"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .text_event_hyphen_stream
                ]
            }
        }
    }
    /// Translates audio into English.
    ///
    /// - Remark: HTTP `POST /audio/translations`.
    /// - Remark: Generated from `#/paths//audio/translations/post(createTranslation)`.
    public enum createTranslation {
        public static let id: Swift.String = "createTranslation"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/audio/translations/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createTranslation.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createTranslation.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.createTranslation.Input.Headers
            /// - Remark: Generated from `#/paths/audio/translations/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/audio/translations/POST/requestBody/multipartForm`.
                @frozen public enum multipartFormPayload: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/audio/translations/POST/requestBody/multipartForm/file`.
                    public struct filePayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `filePayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case file(OpenAPIRuntime.MultipartPart<Operations.createTranslation.Input.Body.multipartFormPayload.filePayload>)
                    /// - Remark: Generated from `#/paths/audio/translations/POST/requestBody/multipartForm/model`.
                    public struct modelPayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `modelPayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case model(OpenAPIRuntime.MultipartPart<Operations.createTranslation.Input.Body.multipartFormPayload.modelPayload>)
                    /// - Remark: Generated from `#/paths/audio/translations/POST/requestBody/multipartForm/prompt`.
                    public struct promptPayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `promptPayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case prompt(OpenAPIRuntime.MultipartPart<Operations.createTranslation.Input.Body.multipartFormPayload.promptPayload>)
                    /// - Remark: Generated from `#/paths/audio/translations/POST/requestBody/multipartForm/response_format`.
                    public struct response_formatPayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `response_formatPayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case response_format(OpenAPIRuntime.MultipartPart<Operations.createTranslation.Input.Body.multipartFormPayload.response_formatPayload>)
                    /// - Remark: Generated from `#/paths/audio/translations/POST/requestBody/multipartForm/temperature`.
                    public struct temperaturePayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `temperaturePayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case temperature(OpenAPIRuntime.MultipartPart<Operations.createTranslation.Input.Body.multipartFormPayload.temperaturePayload>)
                    /// - Remark: Generated from `#/paths/audio/translations/POST/requestBody/multipartForm/language`.
                    public struct languagePayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `languagePayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case language(OpenAPIRuntime.MultipartPart<Operations.createTranslation.Input.Body.multipartFormPayload.languagePayload>)
                }
                /// - Remark: Generated from `#/paths/audio/translations/POST/requestBody/content/multipart\/form-data`.
                case multipartForm(OpenAPIRuntime.MultipartBody<Operations.createTranslation.Input.Body.multipartFormPayload>)
            }
            public var body: Operations.createTranslation.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.createTranslation.Input.Headers = .init(),
                body: Operations.createTranslation.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/audio/translations/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/audio/translations/POST/responses/200/content/json`.
                    @frozen public enum jsonPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/audio/translations/POST/responses/200/content/json/case1`.
                        case CreateTranslationResponseJson(Components.Schemas.CreateTranslationResponseJson)
                        /// - Remark: Generated from `#/paths/audio/translations/POST/responses/200/content/json/case2`.
                        case CreateTranslationResponseVerboseJson(Components.Schemas.CreateTranslationResponseVerboseJson)
                        public init(from decoder: any Decoder) throws {
                            var errors: [any Error] = []
                            do {
                                self = .CreateTranslationResponseJson(try .init(from: decoder))
                                return
                            } catch {
                                errors.append(error)
                            }
                            do {
                                self = .CreateTranslationResponseVerboseJson(try .init(from: decoder))
                                return
                            } catch {
                                errors.append(error)
                            }
                            throw Swift.DecodingError.failedToDecodeOneOfSchema(
                                type: Self.self,
                                codingPath: decoder.codingPath,
                                errors: errors
                            )
                        }
                        public func encode(to encoder: any Encoder) throws {
                            switch self {
                            case let .CreateTranslationResponseJson(value):
                                try value.encode(to: encoder)
                            case let .CreateTranslationResponseVerboseJson(value):
                                try value.encode(to: encoder)
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/audio/translations/POST/responses/200/content/application\/json`.
                    case json(Operations.createTranslation.Output.Ok.Body.jsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.createTranslation.Output.Ok.Body.jsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.createTranslation.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.createTranslation.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// OK
            ///
            /// - Remark: Generated from `#/paths//audio/translations/post(createTranslation)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.createTranslation.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.createTranslation.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
}
